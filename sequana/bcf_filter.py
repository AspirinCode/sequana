# -*- coding: utf-8 -*-
#
#  This file is part of Sequana software
#
#  Copyright (c) 2016 - Sequana Development Team
#
#  File author(s):
#      Thomas Cokelaer <thomas.cokelaer@pasteur.fr>
#      Dimitri Desvillechabrol <dimitri.desvillechabrol@pasteur.fr>,
#          <d.desvillechabrol@gmail.com>
#
#  Distributed under the terms of the 3-clause BSD license.
#  The full license is in the LICENSE file, distributed with this software.
#
#  website: https://github.com/sequana/sequana
#  documentation: http://sequana.readthedocs.io
#
##############################################################################
"""Analysis of VCF file generated by freebayes. This method need the version
0.10 of pysam.
"""

from pysam import VariantFile
import pandas as pd


class BCF_freebayes(VariantFile):
    """BCF_freebayes class (Binary Variant Calling Format)

    This class is a wrapping of VariantFile class from the pysam package. It
    is dedicated for VCF file generated by freebayes compressed by bcftools.
    BCF file is faster to parse than VCF. A data frame with all variants is
    produced which can be write as csv file. It can filter variants with a
    dictionnary of filter parameter. Filter variants are wrotte in a new
    VCF file.

    ::

        from sequana import sequana_data, BCF_freebayes
        bcf_filename = sequana_data("test.bcf", "testing")

        # Read the data
        b = BCF_freebayes(bcf_filename)

        # Filter the data
        filter_dict = {"freebayes_score": 200,
                       "frequency": 0.8,
                       "min_depth": 10,
                       "forward_depth":3,
                       "reverse_depth":3,
                       "strand_ratio": 0.2}
        b.filter_bcf(filter_dict, "output.vcf")
    """
    def __init__(self, input_filename, **kwargs):
        """
        Filter bcf file with a dictionnary.

        :param str filename: a bcf file.
        :param kwargs: any arguments accepted by VariantFile.
        """
        super().__init__(input_filename, **kwargs)
        self._bcf_to_df()

    def _strand_ratio(self, number1, number2):
        try:
            division = float(number1) / (number1 + number2)
            if division > 0.5:
                division = 1 - division
        except ZeroDivisionError:
            return 0
        return division

    def _compute_freq(self, bcf_line):
        """ Compute frequency off alternate allele.
            alt_freq = Count Alternate Allele / Depth
        """
        alt_freq = [float(count)/bcf_line.info["DP"]
                    for count in bcf_line.info["AO"]]
        return alt_freq

    def _compute_strand_bal(self, bcf_line):
        """ Compute strand balance of alternate allele include in [0,0.5].
            strand_bal = Alt Forward / (Alt Forward + Alt Reverse)
        """
        strand_bal = [self._strand_ratio(bcf_line.info["SAF"][i],
                      bcf_line.info["SAR"][i])
                      for i in range(len(bcf_line.info["SAF"]))]
        return strand_bal

    def _filter_line(self, bcf_line, filter_dict):
        """ Filter variant with parameter set in filter_dict.
            Filter_dict must have this form:

            filter_dict = {"freebayes_score": 200,
                           "frequency": 0.8,
                           "min_depth": 10,
                           "forward_depth":3,
                           "reverse_depth":3,
                           "strand_ratio": 0.2}

            return line if all filters are crossed
        """
        if bcf_line.qual < filter_dict["freebayes_score"]:
            return False

        if bcf_line.info["DP"] <= filter_dict["min_depth"]:
            return False

        forward_depth = bcf_line.info["SRF"] + sum(bcf_line.info["SAF"])
        if forward_depth <= filter_dict["forward_depth"]:
            return False

        reverse_depth = bcf_line.info["SRR"] + sum(bcf_line.info["SAR"])
        if reverse_depth <= filter_dict["reverse_depth"]:
            return False

        alt_freq = self._compute_freq(bcf_line)
        if alt_freq[0] < filter_dict["frequency"]:
            return False

        strand_bal = self._compute_strand_bal(bcf_line)
        if strand_bal[0] < filter_dict["strand_ratio"]:
            return False

        return True

    def filter_bcf(self, filter_dict, output):
        """ Read the bcf file and write the filter bcf file.
        """
        with open(output, "w") as fp:
            print(self.header, end="", file=fp)
            for variant in self:
                if self._filter_line(variant, filter_dict):
                    print(variant, end="", file=fp)
        # Rewind the iterator
        self.reset()

    def _bcf_line_to_dict(self, bcf_line):
        """ Convert a BCF line as a dictionnary with the most important
        information to detect real variants.
        """
        # Calcul all important information
        alt_freq = self._compute_freq(bcf_line)
        strand_bal = self._compute_strand_bal(bcf_line)
        line_dict = {"chr": bcf_line.chrom, "position": str(bcf_line.pos),
                     "depth": bcf_line.info["DP"], "reference": bcf_line.ref,
                     "alternative": "; ".join(str(x) for x in bcf_line.alts),
                     "freebayes_score": bcf_line.qual,
                     "strand_balance": "; ".join(
                         "{0:.2f}".format(x) for x in strand_bal),
                     "frequency": "; ".join(
                         "{0:.2f}".format(x) for x in alt_freq)}
        try:
            # If bcf is annotated by snpEff
            annotation = bcf_line.info["EFF"][0].split("|")
            effect_type, effect_lvl = annotation[0].split("(")
            try:
                prot_effect, cds_effect = annotation[3].split("/")
            except ValueError:
                cds_effect = annotation[3]
                prot_effect = ""
            ann_dict = {"CDS_position": cds_effect[2:],
                        "effect_type": effect_type,
                        "codon_change": annotation[2],
                        "gene_name": annotation[5],
                        "mutation_type": annotation[1],
                        "prot_effect": prot_effect[2:],
                        "prot_size": annotation[4],
                        "effect_impact": effect_lvl}
            line_dict = dict(line_dict, **ann_dict)
        except KeyError:
            pass
        return line_dict

    def _bcf_to_df(self):
        """ Create a data frame with the most important information contained
        in the bcf file.
        """
        dict_list = [self._bcf_line_to_dict(variant) for variant in self]
        self.df = pd.DataFrame.from_records(dict_list)
        cols = self.df.columns.tolist()
        try:
            # If bcf is annotated by snpEff with EFF format
            self.df = self.df[[cols[2], cols[11], cols[14], cols[1], cols[4],
                               cols[8], cols[15], cols[7], cols[6], cols[10],
                               cols[5], cols[9], cols[0], cols[3], cols[12],
                               cols[13]]]
        except (ValueError, IndexError):
            if cols:
                self.df = self.df[[cols[1], cols[5], cols[6], cols[0], cols[2],
                                   cols[4], cols[7], cols[3]]]
        # Rewind the iterator
        self.reset()

    def to_csv(self, output_filename):
        """ Write DataFrame in csv format.
        """
        with open(output_filename, "w") as fp:
            print("# sequana_variant_filter", file=fp)
            self.df.to_csv(fp, index=False)
