"""Phix removal pipeline

Author: Thomas Cokelaer
Affiliation: Institut Pasteur @ 2016

This pipeline is part of Sequana software (sequana.readthedocs.io)
"""
import os
import sequana
from sequana import snaketools as sm
from sequana.snaketools import SequanaConfig, FileFactory
sm.init("quality_control.rules", globals())


# This must be defined before the include 
configfile: "config.yaml"
cfg = SequanaConfig(config)
cfg.config.pipeline_name = "quality_control"


# Generic include of some dynamic modules
exec(open(sequana.modules["bwa_mem_dynamic"], "r").read())
exec(open(sequana.modules["fastqc"], "r").read())
exec(open(sequana.modules["fastq_stats"], "r").read())

# first input rule must be included in the try/except
# recovers differents samples in directory
try:
    glob_dir = config["input_directory"] + "/test*fastq.gz"
    ff = sm.FastQFactory(glob_dir)
except:
    ff = sm.FastQFactory(cfg.DATASET)

ff_dict = {tag: [ff.get_file1(tag), ff.get_file2(tag)] if ff.get_file2(tag) 
            else [ff.get_file1(tag)] for tag in ff.tags}

if len(ff.tags)==1 and cfg.PROJECT:
    project = cfg.PROJECT
    basename = cfg.PROJECT + "/%s/{sample}" 
else:
    project = "{sample}"
    basename = "{sample}/%s/{sample}"


"""if cfg.config.fastq_sampling.do:
    try:
        ff_dict
        __fastq_sampling__input = lambda wildcards: ff_dict[wildcards.sample]
    except NameError:
        #__fastq_sampling__input =  lambda wildcards: 
        __fastq_sampling__output = expand(project + "/fastq_sampling/{sample}", sample=ff.basenames)
    include: sm.modules['fastq_sampling']
"""


__data__input = lambda wildcards: ff_dict[wildcards.sample] 

#__fastq_sampling__input = __data__input
#__fastq_sampling__output = "{sample}/fastq_sampling/{sample}" + ".fastq.gz"
#include: sm.modules['fastq_sampling']
#ff = sm.FastQFactory("*/fastq_sampling/*.fastq.gz")
#ff_dict = {tag: [ff.get_file1(tag), ff.get_file2(tag)] if ff.get_file2(tag) 
#        else [ff.get_file1(tag)] for tag in ff.tags}


# FASTQC on input data set
__fastqc_samples__input_fastq = __data__input
__fastqc_samples__output_done = "{sample}/fastqc_samples/fastqc.done"
__fastqc_samples__wkdir = "{sample}/fastqc_samples"
include: fastqc_dynamic("samples", project)
expected_output.extend(expand(__fastqc_samples__output_done, sample=ff_dict))


# FASTQ stats on input data set
__fastq_stats_samples__input_fastq = __data__input 
__fastq_stats_samples__output_done ="{sample}/fastq_stats_samples/fastq_stats.done"
__fastq_stats_samples__wkdir = "{sample}/fastq_stats_samples"
include: fastq_stats_dynamic("samples", project)
expected_output.extend(expand(__fastq_stats_samples__output_done, sample=ff_dict))


if cfg.config.bwa_mem_phix.do:
    # Mapping input / output
    __bwa_mem_phix__input = __data__input
    __bwa_mem_phix__ref_input = config["bwa_mem_phix"]["reference"]
    __bwa_mem_phix__reference = basename % ("reference") + ".fasta"
    __bwa_mem_phix__mem_output = basename % ("bwa_mem_ref") + ".bam"
    __bwa_mem_phix__sort_output = basename % ("bwa_mem_ref") + ".sorted.bam"
    include: bwa_mem_dynamic("phix", project)

    # BWA_BAM_TO_FASTQ 
    __format = basename % "bwa_bam_to_fastq" + "_{read}_.{tag}.fastq.gz"
    __bwa_bam_to_fastq__input = __bwa_mem_phix__sort_output

    if cfg.paired is True:
        #__bwa_bam_to_fastq__fastq_output = expand(
        #    __format, read=["R1", "R2"], tag=["mapped", "unmapped"], sample=ff_dict)
        def _mapper(ff):
            f1 = [x.replace("fastq.gz", "mapped.fastq.gz") for x in ff]
            f2 = [x.replace("fastq.gz", "unmapped.fastq.gz") for x in ff]
            return f1 + f2

        __bwa_bam_to_fastq__fastq_output = [
            "{sample}/bwa_bam_to_fastq/{sample}_R1_.unmapped.fastq.gz",
            "{sample}/bwa_bam_to_fastq/{sample}_R1_.mapped.fastq.gz",
            "{sample}/bwa_bam_to_fastq/{sample}_R2_.unmapped.fastq.gz",
            "{sample}/bwa_bam_to_fastq/{sample}_R2_.mapped.fastq.gz"]

        __bwa_bam_to_fastq__stats_output = "{sample}/bwa_bam_to_fastq/bwa_mem_stats.json"
        __bwa_bam_to_fastq__wkdir = "{sample}/bwa_bam_to_fastq"
    else:
        __bwa_bam_to_fastq__fastq_output = expand(
            __format % {'proj':project},
            read=["R1"], tag=["mapped", "unmapped"])
            #__bwa_bam_to_fastq__stats_output =
    include: sm.modules['bwa_bam_to_fastq']

    # Run a fastqc and fastq_stats on the data without phix
    __fastqc_phix__input_fastq = __bwa_bam_to_fastq__fastq_output
    __fastqc_phix__output_done = "{sample}/fastqc_phix/fastqc.done"
    __fastqc_phix__wkdir = "{sample}/fastqc_phix/"
    include: fastqc_dynamic("phix", project)
    expected_output.extend(expand(__fastqc_phix__output_done, sample=ff_dict))

    __fastq_stats_phix__input_fastq = __bwa_bam_to_fastq__fastq_output
    __fastq_stats_phix__wkdir = "{sample}/fastq_stats_phix"
    __fastq_stats_phix__output_done ="{sample}/fastq_stats_phix/fastq_stats.done"
    include: fastq_stats_dynamic("phix", project)
    expected_output.extend(expand(__fastq_stats_phix__output_done, sample=ff_dict))



if cfg.config.adapter_removal.do:
    adapter_removal = cfg.config.adapter_removal.tool

    if adapter_removal in ["cutadapt"]:
        __cutadapt__input_fastq = [x for x in __bwa_bam_to_fastq__fastq_output if "unmapped" in x]
        __cutadapt__wkdir = "{sample}/cutadapt"
        __cutadapt__output = [x.replace("bwa_bam_to_fastq", "cutadapt").replace("unmapped","cutadapt")
            for x in __cutadapt__input_fastq]
        if "adapter_fwd" in cfg.config.adapter_removal.fwd :
            cfg.config.adapter_removal.fwd = ""
        if "adapter_rev" in cfg.config.adapter_removal.rev:
            cfg.config.adapter_removal.rev = ""
        __cutadapt__options = cfg.config.adapter_removal.options
        __cutadapt__mode = cfg.config.adapter_removal.mode
        __cutadapt__log = "{sample}/logs/cutadapt/cutadapt.txt"
        include: sm.modules["cutadapt"]
    elif adapter_removal == "atropos":
        raise NotImplementedError
        include: sm.modules["atropos"]
    elif adapter_removal == "skewer":
        raise NotImplementedError
        include: sm.modules["skewer"]
    else:
        raise ValueError("trimming must be either cutadapt or atropos or skewer")

    __fastqc_cutadapt__input_fastq = __cutadapt__output
    __fastqc_cutadapt__output_done = "{sample}/fastqc_cutadapt/fastqc.done"
    __fastqc_cutadapt__wkdir = "{sample}/fastqc_cutadapt/"
    include: fastqc_dynamic(adapter_removal, project)
    expected_output += expand(__fastqc_cutadapt__output_done, sample=ff_dict)

    __fastq_stats_cutadapt__input_fastq = __cutadapt__output
    __fastq_stats_cutadapt__wkdir = "{sample}/fastq_stats_cutadapt"
    __fastq_stats_cutadapt__output_done ="{sample}/fastq_stats_cutadapt/fastq_stats.done"
    include: fastq_stats_dynamic(adapter_removal, project)
    expected_output += expand(__fastq_stats_cutadapt__output_done, sample=ff_dict)



if cfg.config.kraken.do:
    if cfg.config.adapter_removal.do:
        # todo: handle all adapter removal cases
        __kraken__input = __cutadapt__output
    elif cfg.config.phix_removal.do:
        __kraken__input = [x for x in __bwa_bam_to_fastq__output if "unmapped" in x]
    else:
        __kraken__input = __data_input

    __kraken__output_wkdir = "{sample}/kraken"
    __kraken__output_html = "{sample}/kraken/kraken.html"
    __kraken__output = "{sample}/kraken/kraken.out"
    include: sm.modules['kraken']
    expected_output.append(expand(__kraken__output_html, sample=ff_dict))

__dag__input = __snakefile__
__dag__output = "dag.svg"
include: sm.modules['dag']
expected_output.extend(["dag.svg"])

__rulegraph__input = __snakefile__
__rulegraph__output = "rulegraph.svg"
include: sm.modules['rulegraph']
expected_output.extend(["rulegraph.svg"])


# Add Conda
__conda__output = "requirements.txt"
include: sm.modules['conda']   # Create requirements.txt(dependencies)
expected_output.extend([__conda__output])

# Those rules takes a couple of seconds so no need for a cluster
localrules: dag, conda


rule pipeline_quality_control:
    input: expected_output



onsuccess:
    import os
    # Create plots about stats
    sm.plot_stats(N=len(ff_dict))

    # files to remove
    # Main directory
    report_dir_format = "%(proj)s/%(proj)s_report_qc/"
    for proj in ff_dict.keys():
        report_dir = report_dir_format % {"proj": proj}
        try:os.mkdir(report_dir)
        except:pass
        shell("cp %s %s" % (__snakefile__, report_dir))
        shell("cp rulegraph.svg %s/dag.svg" % (report_dir))
        shell("cp config.yaml %s" % report_dir)
        shell("cp requirements.txt %s" % report_dir)
        shell("cp snakemake_stats.png %s" % report_dir)

        if cfg.config.adapter_removal.do:
            from sequana.reporting import report_cutadapt
            this = report_cutadapt.CutAdaptReport(proj, directory=report_dir)
            this.read_data(proj + "/logs/cutadapt/{0}.txt".format("cutadapt"))
            this.create_report()

        if cfg.config.kraken.do:
            shell('cp -r %s/kraken/ %s' % (proj, report_dir))
        shell('cp -r %s/fastqc_*/ %s' % (proj, report_dir))
        shell('cp -r %s/fastq_stats*/ %s' % (proj, report_dir))

        # Copy the fastq files 
        if cfg.config.adapter_removal.do:
            shell('cp -r %s/cutadapt/*fastq.gz %s' % (proj, report_dir))
        elif cfg.config.bwa_mem_phix.do:
            shell('cp -r %s/bwa_bam_to_fastq/*unmapped* %s' % (proj, report_dir))

        from sequana import SequanaSummary
        summary = SequanaSummary(proj, directory=report_dir, 
            output_filename="summary.html", 
            snakefile=__snakefile__, configfile=report_dir+"/config.yaml")
        summary.copy_images_to_report(proj + "/*/images/*png")
        summary.create_report()
    garbage = ['snakemake_stats.png',  "rulegraph.svg", "requirements.txt"]
    for filename in garbage:
        print(filename)
        import os
        try: os.remove(filename)
        except:pass
    sm.touch("finished")

onerror:
    print("An error occurred. See message above.")


